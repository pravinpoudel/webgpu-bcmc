#version 450 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#include "util.glsl"


// interesting finding "openGL treats a vec3 as an vec4" so volume_dims is vec4 though data in it is vec3

// [Refernce to GLSL and OpenGL] std140 is memory layout which explicitly states that each variable
// (in this case volume_dims ,....) will be laidout immediately after previous.

// which means that we can replicae the memory layout in C with struct and instead
// of querying and saving offset for individual value within block from C, we can
// just glBufferData(GL_UNIFORM_BUFFER, sizeof(my_struct), &my_struct) with just one call

layout(set = 0, binding = 0, std140) uniform VolumeParams
{
    uvec4 volume_dims;
    uvec4 padded_dims;
    vec4 volume_scale;
    uint max_bits;
    float isovalue;
    uint image_width;
};

layout(set = 0, binding = 1, std140) uniform coarsedParam
{
    ivec4 coarsed_dims;
};


layout(set = 0, binding = 2, std430) buffer BlockInformation
{
    BlockRange block_ranges[];
};


layout(set = 0, binding = 3, std430) buffer CoarseBlockInformation
{
    CoarsedBlockRange coarsedRange[];
};

uniform layout(set = 0, binding = 4, rgba8) writeonly image2D render_target;


layout(set = 1, binding = 0, std140) uniform BlockIDOffset
{
    uint block_id_offset;
};

void main(void){
	const uint coarsed_block_index = gl_GlobalInvocationID.x + block_id_offset;
	const uint total_coarsed_block = coarsed_dims.x*coarsed_dims.y*coarsed_dims.z;

	// i dont think we need to do this because we are considering
	// totalWorkGroups % device.limits.maxComputeWorkgroupsPerDimension on dispatch size array calculation

	if(coarsed_block_index>= total_coarsed_block){

		return;
	}
    
	uvec3 coarsedBlock;
    coarsedBlock.x = (coarsed_block_index % 16) * 16;
    coarsedBlock.y = ((coarsed_block_index / 16) % 16) * 16;
    coarsedBlock.z = (coarsed_block_index / (16 * 16)) * 16; // integer division is integer implicitly


    const uvec3 n_blocks = padded_dims.xyz / uvec3(4);
    vec2 coarsed_range = vec2(1e20, -1e20);

    bvec3 partial = greaterThan(coarsedBlock + 4, n_blocks.xyz);
	uvec3 local_block_count = uvec3(partial.x ? n_blocks.x - coarsedBlock.x : 4,
            partial.y ? n_blocks.y - coarsedBlock.y : 4,
            partial.z ? n_blocks.z - coarsedBlock.z : 4);

    for (int i = 0; i < local_block_count.x; i++) {
        for (int j = 0; j < local_block_count.y; j++) {
            for (int k = 0; k < local_block_count.z; k++) {
                uvec3 child_block_pos = 4 * coarsedBlock + uvec3(i, j, k); //check for the boundary condition
                if (!any(greaterThanEqual(child_block_pos, n_blocks))) {
                    uint child_block_id = child_block_pos.x + n_blocks.x * (child_block_pos.y + n_blocks.y * child_block_pos.z);
                    coarsed_range.x = min(coarsed_range.x, block_ranges[child_block_id].range.x);
                    coarsed_range.y = max(coarsed_range.y, block_ranges[child_block_id].range.y);
                }
            }
        }
    }
    coarsedRange[coarsed_block_index].range = coarsed_range;

    //imagestore() is glsl function write a textel into an image (image, cordinate,sample (optional), date)
    // imageStore(render_target, ivec2(coarsedBlock.x, coarsedBlock.y), vec4(coarsed_range.x, coarsed_range.y, 1.0, 1.0));
}