#version 450 core

// See https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf

layout(local_size_x = BLOCK_SIZE / 2) in;

layout(set = 0, binding = 0, std430) buffer Data {
    uint vals[];
};

layout(set = 0, binding = 1, std430) buffer BlockSums {
    uint block_sums[];
};

shared uint chunk[BLOCK_SIZE];

void main(void) {
    chunk[2 * gl_LocalInvocationID.x] = vals[2 * gl_GlobalInvocationID.x];
    chunk[2 * gl_LocalInvocationID.x + 1] = vals[2 * gl_GlobalInvocationID.x + 1];

    uint offs = 1;

    // each other thread will add the adjacent block data
    //for ease of understanding
    // for(let s = 1; s<BLOCK_SIZE; s*=2){
    //  only perform computation and overwrite in thread with 2^tree_height and this modulus is to overwrite first element in two adjacent
    // target index of array
    //      condition start to satisfying from zero and it is doing a[i] += a[i+1]
    //     if(threadId.x%(2*s) == 0){
    //         partial_sum[threadId.x] += partial_sum[threadId.x +s];
    //     }
        // __syncthreads()  //remember that all the threads should be synchronized in each iteration step
        // i.e inside for loop not outside; 
    // }

    //once we get the partial sum of block-size number of element, it will be total/block-size number of result
    // which we want to sum again and fot that we need to get all the partial results in one place
    // things to note here- we are just using thread 0 for writting and the result is indexed to the index of block which is smart; that
    // way it get to its correct position
    // if(threadIdx.x == 0){
    //     result[blockId.x] = partial_sum[0];
    // }
    

    // Reduce step up tree
    for (int d = BLOCK_SIZE >> 1; d > 0; d = d >> 1) {
        barrier();
        if (gl_LocalInvocationID.x < d) {
            uint a = offs * (2 * gl_LocalInvocationID.x + 1) - 1;
            uint b = offs * (2 * gl_LocalInvocationID.x + 2) - 1;
            chunk[b] += chunk[a];
        }
        offs = offs << 1;
    }

    // added value is on second element b so result of sum by all thread in a workgroup
    // is in chunk[BLOCKSIZE-1]; if we had put it in a, it would have been in chunk[0] 
    if (gl_LocalInvocationID.x == 0) { // because we are using first thread to do this;
                                       //nothing serious
        block_sums[gl_WorkGroupID.x] = chunk[BLOCK_SIZE - 1];
        chunk[BLOCK_SIZE - 1] = 0;
    }

    // Sweep down the tree to finish the scan
    for (int d = 1; d < BLOCK_SIZE; d = d << 1) {
        offs = offs >> 1;
        barrier();
        if (gl_LocalInvocationID.x < d) {
            uint a = offs * (2 * gl_LocalInvocationID.x + 1) - 1;
            uint b = offs * (2 * gl_LocalInvocationID.x + 2) - 1;
            const uint tmp = chunk[a];
            chunk[a] = chunk[b];
            chunk[b] += tmp;
        }
    }

    barrier();
    vals[2 * gl_GlobalInvocationID.x] = chunk[2 * gl_LocalInvocationID.x];
    vals[2 * gl_GlobalInvocationID.x + 1] = chunk[2 * gl_LocalInvocationID.x + 1];
}

