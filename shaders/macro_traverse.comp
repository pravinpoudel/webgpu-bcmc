#version 450 core

#include "util.glsl"

layout(set = 0, binding = 0, std140) uniform VolumeParams {
    uvec4 volume_dims;
    uvec4 padded_dims;
    vec4 volume_scale;
    uint max_bits;
    float isovalue;
    uint image_width;
};

layout(set = 0, binding = 1, std140) uniform ViewParams {
    mat4 proj_view;
    vec4 eye_pos;
    vec4 eye_dir;
    float near_plane;
};

layout(set = 0, binding = 2, std430) buffer BlockRanges {
    BlockRange block_ranges[];
};

layout(set = 0, binding = 3, std430) buffer RayInformation {
    RayInfo rays[];
};

layout(set = 0, binding = 4, std430) buffer CoarsedRanges {
    CoarsedBlockRange coarse_ranges[];
};

uniform layout(set = 0, binding = 5, rgba8) writeonly image2D render_target;

vec4 block_id_to_color(const uvec3 block_id) {
    const vec3 n_blocks = padded_dims.xyz / uvec3(4);
    return vec4(vec3(block_id) / n_blocks, 1.0);
}
void main() {
    uint ray_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * image_width;

    if (rays[ray_index].t == FLT_MAX) {
        return;
    }
    const uvec3 n_blocks = padded_dims.xyz / uvec3(4);
    const vec3 macrogrid_dims = vec3(n_blocks);

    const ivec3 n_coarsedGrid = ivec3(ceil(vec3(padded_dims)/vec3(16.0)));
    const vec3 coarsedgrid_dims = vec3(n_coarsedGrid);
    // Transform the ray into the dual grid space
    vec3 volume_translation = vec3(0) - volume_scale.xyz * 0.5;
    vec3 transformed_eye = (eye_pos.xyz - volume_translation) / volume_scale.xyz;
    vec3 vol_eye = transformed_eye * volume_dims.xyz - vec3(0.5);
    vec3 grid_ray_dir = rays[ray_index].ray_dir;

    // Transform to the macrocell grid
    // Note: ray dir is NOT normalized here, because the t values are relative
    // to the full volume grid.
    vol_eye *= 0.25;
    grid_ray_dir *= 0.25;

    float t_current = rays[ray_index].t;
    vec3 p = (vol_eye + t_current * grid_ray_dir);
    p = clamp(p, vec3(0), vec3(macrogrid_dims - 1));
    const vec3 inv_grid_ray_dir = 1.0 / grid_ray_dir;
    vec3 cell = floor(p);

    // find intersection point in the grid relative to the coarsed block (16x16x16)
    vec3 vol_eye1 = vol_eye * 0.25;
    vec3 grid_ray_dir1 = grid_ray_dir * 0.25;
    vec3 p1 = (vol_eye1 + t_current * grid_ray_dir1);
    p1 = clamp(p1, vec3(0), vec3(coarsedgrid_dims - 1));

    const vec3 inv_grid_ray_dir1 = 1.0 / grid_ray_dir1;
    vec3 cell1 = floor(p1);

    const vec3 t_max_neg = (cell - vol_eye) * inv_grid_ray_dir;
    const vec3 t_max_pos = (cell + vec3(1.0) - vol_eye) * inv_grid_ray_dir;
    bvec3 is_neg_dir = lessThan(grid_ray_dir, vec3(0));
    // Pick between positive/negative t_max based on the ray sign
    // minimum traversal length is size of voxel/ray direction; in our case size of voxel is 1 so inverse ray direction
    // is traversal length in respective direction but that is direction so we do sign() to get modulus value
    vec3 t_max = mix(t_max_pos, t_max_neg, is_neg_dir);
    const ivec3 grid_step = ivec3(sign(grid_ray_dir));

    // const vec3 t_max_neg1 = (cell1 - vol_eye1) * inv_grid_ray_dir1;
    // const vec3 t_max_pos1 = (cell1+ vec3(1) - vol_eye1) * inv_grid_ray_dir1; 
    // we dont need to do this because it is same vector so value will be same but doing just for sanity
    // is_neg_dir = lessThan(grid_ray_dir1, vec3(0));
    // vec3 t_max1 = mix(t_max_pos1, t_max_neg1, is_neg_dir);
  
    // Note: each voxel is a 1^3 box on the grid
    const vec3 t_delta = abs(inv_grid_ray_dir);
    const vec3 t_delta1 = abs(inv_grid_ray_dir1);

    //while not outside the coarsed grid
    //while not out of the grid
    while (!outside_grid(cell1, coarsedgrid_dims)) {
        const ivec3 coarsedgrid_pos = ivec3(cell1);
        int coarsedgridIndex = coarsedgrid_pos.x + n_coarsedGrid.x* (coarsedgrid_pos.y + n_coarsedGrid.y*coarsedgrid_pos.z);
        float t_next = min(t_max.x, min(t_max.y, t_max.z));
        if (t_next < t_current) {
            break;
        }
        vec2 coarsed_grid_range = coarse_ranges[coarsedgridIndex].range;
      
        if (isovalue >= coarsed_grid_range.x && isovalue <= coarsed_grid_range.y) {

            ivec3 localBoundary = ivec3(coarsedgrid_pos) * 4 + ivec3(4, 4, 4);
            //find partial here and add partial here
            bvec3 partial = greaterThan(localBoundary, n_blocks.xyz);
        	ivec3 local_block_count = ivec3(partial.x ? (n_blocks.x - 4*n_coarsedGrid.x) : 4,
            partial.y ? (n_blocks.y - 4*n_coarsedGrid.y) : 4,
            partial.z ? (n_blocks.z - 4*n_coarsedGrid.z) : 4);
            ivec3 localBoundary2 = ivec3(coarsedgrid_pos)*4 + local_block_count;
            
            
            
            p = (vol_eye + t_current * grid_ray_dir);
            p = clamp(p, vec3(0), vec3(macrogrid_dims - 1));
            cell = floor(p);
            // find t for fine grid
            while (!outside_grid(cell, localBoundary2)) {
                const ivec3 block_pos = ivec3(cell);
                t_next = min(t_max.x, min(t_max.y, t_max.z));
                if (t_next < t_current) {
                    break;
                }
                // imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 0.0, 0.0, 0.3));
                uint block_id = block_pos.x + n_blocks.x * (block_pos.y + n_blocks.y * block_pos.z);
                vec2 cell_range = block_ranges[block_id].range;
                for (int k = 0; k < 2; ++k) {
                    for (int j = 0; j < 2; ++j) {
                        for (int i = 0; i < 2; ++i) {
                            const uvec3 neighbor = uvec3(i, j, k);
                            const uvec3 coords = block_pos + neighbor;
                            if (neighbor == uvec3(0) || any(lessThan(coords, uvec3(0))) ||
                                any(greaterThanEqual(coords, n_blocks))) {
                                continue;
                            }
                            // TODO: use fcn
                            const uint neighbor_id = coords.x + n_blocks.x * (coords.y + n_blocks.y * coords.z);
                            cell_range.x = min(block_ranges[neighbor_id].range.x, cell_range.x);
                            cell_range.y = max(block_ranges[neighbor_id].range.y, cell_range.y);
                        }
                    }
                }
                if (isovalue >= cell_range.x && isovalue <= cell_range.y) {
                    rays[ray_index].block_id = block_id;
                    rays[ray_index].t = t_current;
                    rays[ray_index].t_next = t_next;
                    return;
                }
                //2 ray movement one in block and coarsed group
                t_current = t_next;
                // Advance in the grid
                if (t_current == t_max.x) {
                    cell.x += grid_step.x;
                    t_max.x += t_delta.x;
                } else if (t_current == t_max.y) {
                    cell.y += grid_step.y;
                    t_max.y += t_delta.y;
                } else {
                    cell.z += grid_step.z;
                    t_max.z += t_delta.z;
                }
            }
            vec3 current_p1 = (vol_eye1 + t_current * grid_ray_dir1);
            current_p1 = clamp(current_p1, vec3(0), vec3(coarsedgrid_dims - 1));
            cell1 = floor(current_p1);
            // float t_next1 =  min(t_max.x, min(t_max.y, t_max.z));
        }
        else {
            t_current = t_next;
            if (t_current == t_max.x) {
                t_max.x += t_delta1.x;
                cell1.x += grid_step.x;
            } else if (t_current == t_max.y) {
                t_max.y += t_delta1.y;
                cell1.y += grid_step.y;
            } else {
                t_max.z += t_delta1.z;
                cell1.z += grid_step.z;
            }
        }
    }
    rays[ray_index].block_id = UINT_MAX;
    rays[ray_index].t = FLT_MAX;
    // Rays that exit the macrocell grid write the background color
    imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), vec4(1));
}